# Введение
---
### Определения
 - «Распределенная система это набор независимых узлов (компьютеров), которые представляются пользователю как единая система.»<!-- .element: class="size"  -->
 - «Распределенная система это собрание независимых компьютеров соединенных сетью с программным обеспечением, обеспечивающим их совместное функционирование.»<!-- .element: class="size"  -->
 - «Система, состоящая из набора двух или более независимых узлов, которые координируют свою работу посредством синхронного или асинхронного обмена сообщениями.»<!-- .element: class="size"  -->
 - «Система, чьи компоненты размещены на различных узлах, взаимодействующие и управляемые только посредством передачи сообщений.»<!-- .element: class="size"  -->
 - «...система нескольких автономных вычислительных узлов, взаимодействующих для выполнения общей цели.»<!-- .element: class="size"  -->
 - «…я не могу объяснить, что такое распределенная система, но узнаю ее как только мне ее покажут»<!-- .element: class="size"  -->
---
### Определения
 - В рамках этого курса мы будем рассматривать такие системы, компоненты которых *выполняются на различных узлах* и взаимодействуют между собой посредством какой-либо *сети передачи данных*
---
### Очевидные последствия
 - Дополнительный компонент с *низкой* надежностью - сеть
    - Значительная задержка при передаче даных (латентность при передаче)
    - Незначительная (по сравнению с RAM) пропускная способность (для RAM десятки ГБайт\с, для сети Гбиты\с)
    - Проблемы безопасности в сети (возможность перехвата и подмены трафика)
    - топология сети может изменяться во время работы приложения
 - Любое распрделенное приложение - по определению параллельное
    - гонки потоков
    - необходимость в синхронизации
---
### Очевидные последствия
 - Сложности с развертыванием приложения
     - Как обновлять приложение, состоящее из десятков компонентов
     - Части приложения могут разворачиваться на "чужих" площадках - вне периметра безопасности
 - Сложности с эксплуатацией и обнаружением сбоев
     - Как понять, что какие-то компоненты распределенного приложения вышли из строя
 - Нет "глобального" состояния системы (нет ни одного процесса в распределенной системе, который бы знал текущее глобальное состояние системы)
 - Строго говоря - нет "глобального" времени (ограниченная точность синхронизации часов) 
---
### Очевидные последствия
 - Распределенные системы сложно проектировать
 - ... сложно разрабатывать
 - ... сложно эксплуатировать

 Зачем они вообще нужны?
---
### Мотивация
 - Естественное разделение. Существуют ситуации, в которых распределенная система - единственная возможность
     - почтовый клиент и почтовый сервер
     - браузер и HTTP-сервер
     - банкомат и процессинговая система банка
     - касса в магазине и процессинг банка\система магазина
     - ...
 - Большинство ИТ-систем, с которыми пользователь сегодня сталкивается - распределенные. Потому что пользователь и выполнение его сервиса находятся в разных местах    
---
### Мотивация
 - Повышение производительности
    - Зачастую один узел системы не может справиться с вычислительной нагрузкой. Увеличивать мощность узла нежелательно (например, дорого). В систему добавляют допонительные узлы
    - Для обеспечения *масштабируемости* система должна быть специальным образом спроектирована. Например, при ее создании могут использоваться специализированные шаблоны или целые библиотеки
    - Вы уже знакомы с таким подходом: MPI как раз решает эту задачу 
---
### Мотивация
 - Отказоустойчивость
    - Отдельные (или все) компоненты системы могут быть дублированы на разных (независимых) узлах. Тогда выход из строя одного (или нескольких - зависит от количества запущенных дубликатов) узла не приводит к прекращению работы системы
    - Часто используется в варианте, когда происходит не дублирование компонентов, а их *перенос* с аварийного узла на рабочий. При этом перерыв в сервисе есть, но он минимальный
    - Часто используется совместно с мероприятиями по обеспечению масштабируемости
---
### Мотивация
 - Другие, чаще всего "экономические" причины : если ваша систем разбита на небольшие компоненты, между которыми четко определен интерфейс, то
    - можно повысить T2M (время от идеи до внедрения) 
        - в такие компоненты можно быстро вносить изменения
        - развертывать при изменениии можно отдельные компоненты, а не все приложение
    - можно повысить продуктивность разработки 
        - разные компоненты могут быть написны на разных ЯП (наиболее подходящих для решения задачи), использовать разные СУБД
        - разные компоненты могут разрабатывать разные команды разработчиков
---
### Общие соображения
 - В зависимости от того, чем именно вызвана необходимость создания распределенной системы, к ее компонентам могут предъявляться разные требования. Однако, можно сформулировать ряд общих требований, видимо подходящих для большинства систем:
     - При проектировании межмодульного интерфейса необходимо внимательно следить за объемом передаваемых данных. Если данных *слишком много*, возможно, вы неправильно провели границы между модулями
     - При прочих равных отдавать предпочтение массированным операциям передачи данных. Передать массив значений *выгоднее*, чем отдельное значение
---
### Общие соображения
 - Старайтесь избегать сильной связанности между компонентами. Компоненты должны "знать" только о тех компонентах, которые им нужны для работы (с которыми они взаимодействуют)
 - Инкапсулируйте компоненты - предоставляйте интерфейс(API), за которым скрыта вся внутренняя логика работы
 - Если есть возможность реализовать компонент без хранения состояния (stateless) - сделайте это
 - Если заботитесь о надежности - позаботьтесь, чтобы в системе не было единой точки отказа (одного компонента, выход из строя которого приведет к краху всей системы)    
---
### Общие соображения
В настоящее время, из соображений максимальной независимости компонентов друг от друга, принят подход, при котором все взаимодействие между компонентами осуществляется посредством API компонента. Это означает, что компонент должен полностью отвечать за сохранение своего состояния (если оно есть), т.е. каждый компонент имеет своб собственную СУБД. Это в корне отличается от привычного подхода, при котором данные всей системы хранятся согласованно и централизованно <!-- .element: class="left small_font" -->

  - Плюсы такого подхода: <!-- .element: class="size"  -->
     - каждый компонент выбирает СУБД и схему данных оптимальную для решения своей задачи <!-- .element: class="size"  -->
     - СУБД и схема данных может быть в любой момент изменена, если это не сказывается на API <!-- .element: class="size"  -->
     - нет единой точки отказа (центральной СУБД) <!-- .element: class="size"  -->
     - нет единого "бутылочного горлышка" производительности (центральной СУБД) <!-- .element: class="size"  --> 
 - Минусы <!-- .element: class="size"  -->
     - необходимо самостоятельно решать проблему согласованности данных для СУБД разных компонент, что может оказаться очень сложной задачей <!-- .element: class="size"  -->
     - у нас теперь нет "простых" транзакций в общей СУБД, любая транзакция становится распределенной <!-- .element: class="size"  -->
---
### Микросервисная архитектура
 - набор правил и соглашений для компонентов распределенной системы
     - сервис решает бизнес-задачу (группировка по бизнес-задачам)
     - сервис **маленький** (разрабатывается одной командой, и его способен понять один человек) 
     - сервисы слабосвязаны (поэтому их при желании можно повторно использовать)
     - используется децентрализованное управление сервисами
     - используется децентрализованное управление данными (у каждого сервиса свое хранилище)
     - используется автоматизация развертывания и мониторинга
---
### Микросервисная архитектура
 - Плюсы
     - маленькие сервисы проще создавать и сопровождать
     - упрощается обновление системы - маленькте автономные сервисы могут быть обновлены независимо
     - для каждого сервиса - подходящая ему технология (ЯП, СУБД, ...)
     - высокая стабильность - отказ сервиса может быть обнаружен и исправлен (в т.ч. автоматически)
     - возможность масштабирования как средство увеличения производительности и надежности
 
---
### Микросервисная архитектура
 - Минусы
     - сервисы маленькие -> много взаимодействий. может страдать производительность -> производительность (и надежность) сети критически важна
     - сервисов много -> нужно много оборудования (узлов) для их развертывания. зачастую *больше* чем для развертывания монолита
     - много сервисов и оборудования - критическая зависимость от средств автоматизации управления
     - много API. нужны способы его описания 
     - при проектировании нужно учитывать много особенностей - асинхронный характер взаимодействия, то, что отдельные сервисы могут быть недоступны и т.д. и т.п. 
---
### Теорема CAP
в любой реализации распределённых вычислений возможно обеспечить не более двух из трёх следующих свойств (это эвристическое утверждение!):<!-- .element: class="left" -->
 - согласованность данных (англ. consistency) — во всех вычислительных узлах в один момент времени данные не противоречат друг другу;
 - доступность (англ. availability) — любой запрос к распределённой системе завершается корректным откликом, однако без гарантии, что ответы всех узлов системы совпадают;
 - устойчивость к разделению (англ. partition tolerance) — расщепление распределённой системы на несколько изолированных секций не приводит к некорректности отклика от каждой из секций.
---
### Теорема CAP
![CapTeorem](https://i0.wp.com/proselyte.net/wp-content/uploads/2022/03/CAP_diagram.png)<!-- .element: width="40%" -->

https://i0.wp.com/proselyte.net/wp-content/uploads/2022/03/CAP_diagram.png<!-- .element: class="copyright-reference"  -->

Таким образом, при создании распределенной системы приходится идти на компромис и выбирать какой-то из вариантов<!-- .element: class="left small_font" -->
---
### Модели архитектуры
  - Модель архитектуры отвечает на вопрос:
     - какие компоненты составляют нашу распределенную систему (и какие у них роли)
     - как компоненты взаимодействуют между собой
  - Выбор архитектуры при проектировании - критически важен. Он влияет на будущие эксплуатационные свойства 
  - Самой простой моделью архитектуры является модель "клиент-сервер"   
---
### Клиент-сервер
 - Клиент: процесс, желающий получить доступ к данным, использует ресурсы и/или выполняет действия на удаленном узле
 - Сервер: процесс, управляющий данными и всеми другими разделяемыми ресурсами, обеспечивающий клиентам доступ к ресурсам и производящий вычисления
 - Взаимодействие: пары запрос/результат. **обычно** (но не обязательно) взаимодействие *синхронное*
 - Пример
     - http-сервер: клиент (броузер) запрашивает страницу, сервер поставляет страницу
     - клиент посылает SQL-запрос на сервер СУБД, сервер его выполняет и возвращает ответ
---
### Клиент-сервер (мобильный код)
 - Мобильный код: код, посланный клиенту, чтобы выполнить его же задачу
![MobileCode](../img/CSMobileCode.png)
---
### Клиент-сервер (мобильный код)
 - Выполнение программы (код + данные), которая перемещается между узлами в сети
     - Выполняет автономную задачу обычно под управлением некоторого другого процесса
     - Имеет внутреннее знание и цели
 - Преимущество: всюду локальный доступ
     - Снижает затраты на коммуникации
 - Потенциальная угроза безопасности
     - Ограниченная применимость
 - Примеры: сбор данных из многих источников, установка программ, программы типа червей (электронная почта)
---
### Модель с прокси-сервером
![Proxy](../img/CSProxy.png)
---
### Модель с прокси-сервером
 - Кэш: «близкая» копия, наиболее часто используемых данных
     - ЗНАЧИТЕЛЬНО повышает производительность большинства приложений
     - Но требует усилий по поддержанию когерентности
 - Прокси-сервер: разделяемый кэш ресурсов
     - Еще сложнее, чем простой Кэш…
     - Обычно используется (и хорошо подходит) для доступа к мало меняющимся или *неважным* данным
---
### Модель «пул серверов» (сервис)
![Service](../img/CSService.png)
---
### Модель «пул серверов» (сервис) 
 - Услуги могут обеспечиваться многими серверами 
 - Распределенные между серверами объекты
 - Реплицированные объекты
     - Увеличение производительности, доступности и отказоустойчивости
 - Но требуют координации копий / консистентности представления
 - Например, высокодоступные серверы (порталы, диллинговые центры), информационные службы
 - Серверы, обслуживающие распределенную БД
---
### Модели архитектуры 
 - Другой часто применяемой моделью построения распределенных приложений является **событийная модель**
 - В рамках этой модели система разрабатывается как набор компонентов, обменивающихся сообщениями
 - Взаимодействие компонентов в рамках этой модели **обычно** *асинхронное*  
---
### Событийная модель 
 - Плюсы
     - слабая связанность между компонентами системы. в систему легко добавляются новые компоненты
     - разные компоненты независимы и могут запускаться в разное время
     - легче проектировать системы с высокой масштабируемостью  
 - Минусы
     - необходим допонительный компонент (брокер сообщений, шина, ...)
     - может быть сложно реализовать некоторые сценарии (обработка событий в строгом порядке, откат операций, гарантированная доставка *единственного экземпляра* события и т.д.) 
     - как следствие часто более сложный код 
---
### Модели архитектуры 
 - Распределенные системы часто включают много компонентов и имеют очень сложную структуру. Тем не менее, часто (но не всегда) можно разделить все компоненты системы на части:
     - **Frontend** - компонент (или компоненты), непосредствено взаимодействующие с внешними пользователями (это могут быть другие системы, не обязательно люди), получают запросы, для их обработки обращаются к Backend`у
     - **Backend** - компоненты, отвечающие на "запросы" frontend`a, реализующие основную бизнес-логику системы
     - часто выделяют еще одну группу компонентов - **Data Storage** (хранилище данных)
---
### API Gateway 
 шаблон, представляющий собой единый Frontend для всех сервисов системы<!-- .element: class="left" -->

 ![APIGateway](https://ishantgaurav131.files.wordpress.com/2020/08/api-gateway-1.png)<!-- .element: width="60%" -->

 https://ishantgaurav131.files.wordpress.com/2020/08/api-gateway-1.png<!-- .element: class="copyright-reference" -->
---
### API Gateway 
 - Может решать следующие задачи:
     - Кэширование: ответ от служб может быть кэширован в API-шлюзе
     - Авторизация/Аутентификация: вместо проверки личности клиента и аутентификации на каждом сервисе это можно реализовать в API-шлюзе.
     - Подмена протокола: например https может терминироваться на шлюзе (и тогда для всех сервисов нам нужен только один сертификат)
     - Ограничение количества запросов: шлюз может ограничивать каличество запросов от клиентов, защищая сервисы от перегрузки.
     - Сбор показателей: шлюз может собирать метрики по всем или только необходимым запросам.
---
### API Gateway 
 - Может решать следующие задачи:
     - Сбор логов: шлюз может логгировать события.
     - Клиенту не нужно ничего знать о службах - можно легко добавить новую или изменить\удалить старую.
 - Минусы
     - Может стать слишком сложным
     - Может стать единой точкой отказа всей системы 